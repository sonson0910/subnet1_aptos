# sdk/consensus/scoring.py
"""
Logic chấm điểm kết quả từ miners.
Chứa hàm cơ sở cần được kế thừa và triển khai bởi các validator/subnet cụ thể.
"""
import logging
from typing import List, Dict, Any, Optional, Union, cast, TYPE_CHECKING
from collections import defaultdict
from mt_aptos.metagraph.metagraph_datum import STATUS_ACTIVE, STATUS_INACTIVE
import binascii
import asyncio
import httpx
import json
import nacl.signing
from nacl.exceptions import CryptoError
# Replace pycardano imports with Aptos SDK
from mt_aptos.account import Account

# Giả định các kiểu dữ liệu này đã được import hoặc định nghĩa đúng
try:
    from mt_aptos.core.datatypes import (
        MinerResult,
        TaskAssignment,
        ValidatorScore,
        ValidatorInfo,
        ScoreSubmissionPayload,
    )
except ImportError as e:
    raise ImportError(f"Error importing dependencies in scoring.py: {e}")

logger = logging.getLogger(__name__)


# --- Helper function for canonical serialization ---
def canonical_json_serialize(data: Any) -> str:
    """Serialize dữ liệu thành chuỗi JSON ổn định (sắp xếp key).

    Recursively converts dataclasses and dictionaries, handling bytes by
    encoding them as hex strings. Ensures consistent output for signing
    by sorting dictionary keys.

    Args:
        data: Dữ liệu cần serialize (có thể là dataclass, dict, list, etc.).

    Returns:
        Chuỗi JSON đại diện cho dữ liệu, với keys được sắp xếp.
    """
    import dataclasses  # Ensure dataclasses is imported here or globally

    def convert_to_dict(obj):
        if dataclasses.is_dataclass(obj):
            result = {}
            for f in dataclasses.fields(obj):
                value = getattr(obj, f.name)
                result[f.name] = convert_to_dict(value)
            return result
        elif isinstance(obj, list):
            return [convert_to_dict(item) for item in obj]
        elif isinstance(obj, dict):
            return {k: convert_to_dict(v) for k, v in obj.items()}
        # Thêm xử lý bytes -> hex string để JSON serialize được
        elif isinstance(obj, bytes):
            return obj.hex()
        else:
            return obj

    data_to_serialize = convert_to_dict(data)
    return json.dumps(data_to_serialize, sort_keys=True, separators=(",", ":"))


# --- END INSERT ---

if TYPE_CHECKING:
    # Đảm bảo import đúng đường dẫn tương đối hoặc tuyệt đối
    # from ..consensus.node import ValidatorNode # Incorrect relative path likely
    from mt_aptos.consensus.node import ValidatorNode  # Use absolute path
    from ..core.datatypes import (
        ValidatorScore,
        ValidatorInfo,
    )


# --- 1. Đánh dấu hàm này cần override ---
def _calculate_score_from_result(task_data: Any, result_data: Any) -> float:
    """
    (Trừu tượng/Cần Override) Tính điểm P_miner,v từ dữ liệu task và kết quả.

    Lớp Validator kế thừa cho từng Subnet PHẢI override phương thức này
    với logic chấm điểm phù hợp cho loại nhiệm vụ AI của họ.

    Args:
        task_data: Dữ liệu của nhiệm vụ đã giao (từ TaskAssignment.task_data).
        result_data: Dữ liệu kết quả mà miner trả về (từ MinerResult.result_data).

    Returns:
        Điểm số (từ 0.0 đến 1.0).

    Raises:
        NotImplementedError: Nếu phương thức này không được override bởi lớp con.
    """
    # Hoặc trả về điểm mặc định và log warning:
    logger.warning(
        f"'_calculate_score_from_result' is using the base implementation. "
        f"This should be overridden by specific subnet/validator logic. "
        f"Task data type: {type(task_data)}, Result data type: {type(result_data)}. "
        f"Returning default score 0.0"
    )
    return 0.0
    # Hoặc raise lỗi để bắt buộc override:
    # raise NotImplementedError("Scoring logic must be implemented by validator subclass/subnet.")


# ---------------------------------------


def score_results_logic(
    results_received: Dict[str, List[MinerResult]],
    tasks_sent: Dict[str, TaskAssignment],
    validator_uid: str,
) -> Dict[str, List[ValidatorScore]]:
    """
    Chấm điểm tất cả các kết quả hợp lệ nhận được từ miners cho chu kỳ hiện tại.

    Iterates through results received for each task ID. For each result, it verifies:
    1. If the task ID corresponds to a task actually sent by this validator.
    2. If the result came from the miner the task was assigned to.

    Valid results are then scored using `_calculate_score_from_result`, and a
    `ValidatorScore` object is created.

    Args:
        results_received: Dictionary mapping task IDs to lists of `MinerResult` objects received.
                          {task_id: [MinerResult, MinerResult, ...]}.
        tasks_sent: Dictionary mapping task IDs to the `TaskAssignment` objects sent out.
                    {task_id: TaskAssignment}.
        validator_uid: UID (hex string) of the validator performing the scoring.

    Returns:
        Dictionary mapping task IDs to lists of `ValidatorScore` objects generated by this validator.
        {task_id: [ValidatorScore, ValidatorScore, ...]}. Returns scores only for valid, processed results.
    """
    logger.info(
        f"[V:{validator_uid}] Scoring {len(results_received)} received tasks..."
    )
    validator_scores: Dict[str, List[ValidatorScore]] = defaultdict(list)

    for task_id, results in results_received.items():
        assignment = tasks_sent.get(task_id)
        if not assignment:
            logger.warning(
                f"Scoring skipped: Task assignment not found for task_id {task_id}."
            )
            continue

        # Chỉ chấm điểm kết quả đầu tiên hợp lệ từ đúng miner? Hay chấm tất cả?
        # Tạm thời chấm kết quả đầu tiên từ đúng miner
        valid_result_found = False
        for result in results:
            if result.miner_uid == assignment.miner_uid:
                # Gọi hàm chấm điểm (có thể là hàm đã override)
                try:
                    score = _calculate_score_from_result(
                        assignment.task_data, result.result_data
                    )
                    # Đảm bảo điểm nằm trong khoảng [0, 1]
                    score = max(0.0, min(1.0, score))
                    valid_result_found = True  # Đánh dấu đã tìm thấy kết quả hợp lệ
                except NotImplementedError:
                    logger.error(
                        f"Scoring logic not implemented for task {task_id}! Assigning score 0."
                    )
                    score = 0.0
                    valid_result_found = True  # Vẫn coi như đã xử lý
                except Exception as e:
                    logger.exception(
                        f"Error calculating score for task {task_id}, miner {result.miner_uid}: {e}. Assigning score 0."
                    )
                    score = 0.0
                    # Có nên coi đây là kết quả hợp lệ để dừng không? Tạm thời không.
                    continue  # Thử kết quả tiếp theo nếu có lỗi

                logger.info(
                    f"  Scored Miner {result.miner_uid} for task {task_id}: {score:.4f}"
                )

                val_score = ValidatorScore(
                    task_id=task_id,
                    miner_uid=result.miner_uid,
                    validator_uid=validator_uid,
                    score=score,
                )
                validator_scores[task_id].append(val_score)
                break  # Chỉ chấm điểm kết quả hợp lệ đầu tiên từ đúng miner

        if not valid_result_found:
            logger.warning(
                f"No valid result found from expected miner {assignment.miner_uid} for task {task_id}. No score generated."
            )
            # Có thể tạo điểm 0 cho miner nếu không có kết quả hợp lệ?
            # val_score = ValidatorScore(...)
            # validator_scores[task_id].append(val_score)

    logger.info(
        f"Finished scoring. Generated scores for {len(validator_scores)} tasks."
    )
    return dict(validator_scores)


async def broadcast_scores_logic(
    validator_node: "ValidatorNode",
    cycle_scores_dict: Dict[str, List["ValidatorScore"]],
):
    """
    Gửi điểm số cục bộ (local_scores) đến các validator khác (peers), có ký dữ liệu.

    Performs the following steps:
    1. Fetches necessary info (signing key, active peers, http client) from the validator node.
    2. Flattens the `cycle_scores_dict` into a single list, keeping only scores generated
       by this validator (`self_uid`).
    3. If no local scores generated, logs a debug message and returns.
    4. Serializes the filtered list of scores into a canonical JSON string.
    5. Signs the serialized data using the validator's signing key.
    6. Creates a `ScoreSubmissionPayload` containing the scores, signature (hex),
       and the validator's public key.
    7. Iterates through the list of active validator peers (excluding self).
    8. Sends the payload via HTTP POST to the `/submit_scores` endpoint of each peer.

    Args:
        validator_node: The instance of the `ValidatorNode` running this logic.
                        Provides access to configuration, keys, peers, and HTTP client.
        cycle_scores_dict: A dictionary containing scores generated or received
                           during the current cycle, keyed by task ID.
                           {task_id: [ValidatorScore, ...]}. This function will
                           filter and broadcast only the scores generated *by* this node.

    Raises:
        AttributeError: If `validator_node` is missing required attributes/methods.
        TypeError: If the derived verification key type is unexpected.
        CryptoError: If signing fails.
        httpx.RequestError: If sending the request to a peer fails (e.g., connection error, timeout).
        Exception: For other unexpected errors during setup, signing, or sending.
    """
    try:
        # Lấy thông tin cần thiết từ validator_node
        self_validator_info = validator_node.info
        # Lấy signing key từ validator_node
        signing_key = validator_node.signing_key  # type: ignore
        # Lấy danh sách validator *active* từ node
        active_validator_peers = await validator_node._get_active_validators()
        current_cycle = validator_node.current_cycle
        http_client = validator_node.http_client
        settings = validator_node.settings
        self_uid = self_validator_info.uid  # UID của node hiện tại (dạng hex string)
    except AttributeError as e:  # Khôi phục khối except
        logger.error(
            f"Missing required attribute/method on validator_node for broadcasting: {e}"
        )
        return
    except Exception as e:  # Thêm một except chung để bắt lỗi khác khi lấy attributes
        logger.error(f"Error getting attributes from validator_node: {e}")
        return

    # --- Flatten và Lọc điểm cần gửi ---
    local_scores_list: List[ValidatorScore] = []
    for task_id, scores in cycle_scores_dict.items():
        for score in scores:
            if score.validator_uid == self_uid:
                local_scores_list.append(score)

    if not local_scores_list:
        logger.debug(f"[V:{self_uid}] No local scores to broadcast.")
        return

    logger.info(
        f"[V:{self_uid}] Preparing to broadcast {len(local_scores_list)} score entries generated by self for cycle {current_cycle}."
    )
    # Log peers for debugging
    active_peer_uids = [p.uid for p in active_validator_peers if p.uid != self_uid]
    logger.debug(
        f"[V:{self_uid}] Target active peers for broadcast: {active_peer_uids}"
    )

    # --- Ký Dữ liệu ---
    signature_hex: Optional[str] = None
    public_key_hex: Optional[str] = None
    try:
        # Serialize list điểm ĐÃ LỌC VÀ FLATTEN bằng hàm canonical
        data_to_sign_str = canonical_json_serialize(local_scores_list)
        data_to_sign_bytes = data_to_sign_str.encode("utf-8")

        # Ký bằng PyNaCl hoặc Aptos SDK (tùy vào validator_node.signing_key là gì)
        # Ví dụ sử dụng PyNaCl
        nacl_signing_key = nacl.signing.SigningKey(signing_key.private_key)
        signed_data = nacl_signing_key.sign(data_to_sign_bytes)
        signature_bytes = signed_data.signature
        
        # Lấy public key
        public_key_bytes = nacl_signing_key.verify_key.encode()
        
        signature_hex = binascii.hexlify(signature_bytes).decode("utf-8")
        public_key_hex = binascii.hexlify(public_key_bytes).decode("utf-8")
        
        logger.debug(f"[V:{self_uid}] Payload signed successfully.")
    except TypeError as type_e:
        logger.error(
            f"[V:{self_uid}] Type error during key derivation or serialization: {type_e}"
        )
        return
    except CryptoError as sign_e:  # USE IMPORTED CryptoError
        logger.exception(
            f"[V:{self_uid}] Failed to sign broadcast payload (PyNaCl): {sign_e}"
        )
        return
    except Exception as sign_e:  # Bắt lỗi chung khác
        logger.exception(
            f"[V:{self_uid}] Failed to prepare or sign broadcast payload: {sign_e}"
        )
        return

    # --- Tạo Payload ---
    # Đảm bảo các biến cần thiết đã được gán giá trị
    if signature_hex is None or public_key_hex is None:
        logger.error(
            f"[V:{self_uid}] Failed to obtain signature or public key. Aborting broadcast."
        )
        return

    payload = ScoreSubmissionPayload(
        submitter_validator_uid=self_uid,
        cycle=current_cycle,
        scores=local_scores_list,
        signature=signature_hex,
        public_key_hex=public_key_hex,  # Sử dụng trường public_key_hex thay vì submitter_vkey_cbor_hex
    )
    logger.debug(
        f"[V:{self_uid}] ScoreSubmissionPayload created. Scores count: {len(payload.scores)}, Cycle: {payload.cycle}"
    )

    # --- Gửi đến Peers ---
    tasks = []
    peer_endpoints = {}
    for peer_info in active_validator_peers:  # Lấy thông tin endpoint từ ValidatorInfo
        if peer_info.uid == self_uid:
            continue  # Bỏ qua chính mình
        if peer_info.api_endpoint:
            peer_endpoints[peer_info.uid] = (
                f"{peer_info.api_endpoint.rstrip('/')}/submit_scores"
            )
        else:
            logger.warning(
                f"[V:{self_uid}] Peer {peer_info.uid} has no API endpoint defined. Skipping broadcast."
            )

    async def send_score(peer_uid: str, peer_endpoint: str, payload_dict: dict):
        """Gửi payload điểm số đến một peer cụ thể."""
        try:
            # === FIX: Remove incorrect async with for shared client ===
            # async with http_client as client:  # Sử dụng http_client từ validator_node
            # Use the shared http_client directly
            response = await http_client.post(  # <<< Use http_client directly
                peer_endpoint,
                json=payload_dict,
                headers={"Content-Type": "application/json"},
                timeout=settings.CONSENSUS_NETWORK_TIMEOUT_SECONDS,
            )
            if response.status_code == 200:
                logger.info(
                    f"[V:{self_uid}] Successfully sent scores to peer {peer_uid} at {peer_endpoint}"
                )
            else:
                logger.warning(
                    f"[V:{self_uid}] Failed to send scores to peer {peer_uid} at {peer_endpoint}: Status {response.status_code} - {response.text[:100]}..."
                )
        except httpx.RequestError as req_err:
            logger.warning(
                f"[V:{self_uid}] HTTP request error sending scores to peer {peer_uid} at {peer_endpoint}: {req_err}"
            )
        except Exception as e:
            logger.error(
                f"[V:{self_uid}] Unexpected error sending scores to peer {peer_uid} ({peer_endpoint}): {e}",
                exc_info=True,
            )

    payload_as_dict = payload.dict()  # Chuyển payload thành dict một lần
    for peer_uid, endpoint in peer_endpoints.items():
        tasks.append(send_score(peer_uid, endpoint, payload_as_dict))

    if tasks:
        logger.info(f"[V:{self_uid}] Broadcasting scores to {len(tasks)} peers...")
        await asyncio.gather(*tasks)
        logger.info(
            f"[V:{self_uid}] Finished broadcasting scores for cycle {current_cycle}."
        )
    else:
        logger.info(
            f"[V:{self_uid}] No active peers with endpoints found to broadcast scores to."
        )
