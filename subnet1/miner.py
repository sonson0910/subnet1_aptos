# File: subnet1/miner.py
# Tri·ªÉn khai c·ª• th·ªÉ cho Miner trong Subnet 1 (Image Generation)

import time
import logging
import traceback
import requests
import binascii # Th√™m import n·∫øu ch∆∞a c√≥ (d√π kh√¥ng d√πng tr·ª±c ti·∫øp ·ªü ƒë√¢y)
from typing import Optional
import base64
from io import BytesIO
import os
from fastapi.responses import JSONResponse
import uvicorn
from PIL import Image
import httpx
import random

# Import t·ª´ SDK Moderntensor
try:
    # TaskModel v√† ResultModel ƒë·ªãnh nghƒ©a c·∫•u tr√∫c d·ªØ li·ªáu API
    # BaseMiner cung c·∫•p khung c∆° b·∫£n cho server miner
    from mt_aptos.network.server import BaseMiner, TaskModel, ResultModel
except ImportError:
    logging.error("Could not import BaseMiner, TaskModel, or ResultModel from mt_aptos.network.server. "
                  "Make sure the moderntensor SDK is installed correctly.")
    # L·ªõp gi·∫£ ƒë·ªÉ tr√°nh l·ªói n·∫øu import th·∫•t b·∫°i
    class TaskModel:
         task_id: str = "dummy_task"
         description: Optional[str] = None
         deadline: Optional[str] = None
         priority: Optional[int] = None
         validator_endpoint: Optional[str] = None
    class ResultModel: pass
    class BaseMiner:
        def __init__(self, *args, **kwargs):
             self.validator_url = kwargs.get('validator_url') # URL validator m·∫∑c ƒë·ªãnh (fallback)
        def process_task(self, task: TaskModel) -> dict: return {}
        def handle_task(self, task: TaskModel): pass # Th√™m handle_task gi·∫£
        def run(self): pass # Th√™m run gi·∫£


# Import t·ª´ c√°c module kh√°c trong subnet n√†y
try:
    # C√°c h√†m ƒë·ªÉ sinh ·∫£nh v√† chuy·ªÉn ƒë·ªïi sang base64
    from .models.image_generator import generate_image_from_prompt, image_to_base64
except ImportError:
    logging.error("Could not import image generation functions from .models.image_generator.")
    # H√†m gi·∫£ ƒë·ªÉ code ch·∫°y ƒë∆∞·ª£c n·∫øu import l·ªói
    def generate_image_from_prompt(*args, **kwargs): return None
    def image_to_base64(*args, **kwargs): return None

# L·∫•y logger
logger = logging.getLogger(__name__)

# --- Constants/Config (C√≥ th·ªÉ chuy·ªÉn ra file config ri√™ng) ---
# Thay th·∫ø b·∫±ng model ID b·∫°n mu·ªën d√πng
DEFAULT_MODEL_ID = "segmind/tiny-sd" 
# C√≥ th·ªÉ ƒë·ªçc t·ª´ env var n·∫øu mu·ªën linh ho·∫°t h∆°n
MODEL_ID = os.getenv("IMAGEGEN_MODEL_ID", DEFAULT_MODEL_ID)

# --- 1. Task Processing Logic ---
def generate_image(prompt: str, seed: int = 42) -> bytes:
    """
    Placeholder for actual image generation logic using a model.
    Simulates generation and returns dummy image bytes.
    """
    logger.info(f"üé® Simulating image generation for prompt: '{prompt[:50]}...'")
    # Simulate some processing time
    time.sleep(random.uniform(0.5, 2.0))
    # Create a dummy image representation (e.g., simple text as bytes)
    dummy_image_content = f"Image for '{prompt}' with seed {seed}".encode('utf-8')
    logger.info(f"üñºÔ∏è Simulated image generated (size: {len(dummy_image_content)} bytes).")
    return dummy_image_content


class Subnet1Miner(BaseMiner):
    """
    Miner chuy√™n th·ª±c hi·ªán nhi·ªám v·ª• sinh ·∫£nh cho Subnet 1.
    K·∫ø th·ª´a BaseMiner t·ª´ SDK Moderntensor v√† t√πy ch·ªânh logic x·ª≠ l√Ω task.
    """
    def __init__(
        self,
        validator_url: str,         # URL Validator m·∫∑c ƒë·ªãnh ƒë·ªÉ g·ª≠i k·∫øt qu·∫£ (fallback)
        on_chain_uid_hex: str,    # UID hex on-chain *th·ª±c t·∫ø* c·ªßa miner n√†y
        host: str = "0.0.0.0",      # Host IP ƒë·ªÉ server miner l·∫Øng nghe
        port: int = 8000,         # C·ªïng server miner l·∫Øng nghe
        miner_id: str = "subnet1_miner_default", # ID d·ªÖ ƒë·ªçc ƒë·ªÉ nh·∫≠n di·ªán/logging
        model_id: str = MODEL_ID,
    ):
        """
        Kh·ªüi t·∫°o Subnet1Miner.

        Args:
            validator_url: URL c·ªßa validator m·∫∑c ƒë·ªãnh (d√πng n·∫øu task kh√¥ng c√≥ validator_endpoint).
            on_chain_uid_hex: UID hex on-chain c·ªßa miner n√†y (d√πng trong payload k·∫øt qu·∫£).
            host: ƒê·ªãa ch·ªâ host server miner.
            port: C·ªïng server miner.
            miner_id: T√™n ƒë·ªãnh danh d·ªÖ ƒë·ªçc cho miner n√†y (d√πng cho logging).
            model_id: ID c·ªßa model sinh ·∫£nh (v√≠ d·ª•: t·ª´ Hugging Face).
        """
        # G·ªçi __init__ c·ªßa l·ªõp cha (BaseMiner)
        # Pass miner_uid to BaseMiner's __init__ as well
        super().__init__(validator_url=validator_url, host=host, port=port, miner_uid=on_chain_uid_hex)

        # L∆∞u tr·ªØ c√°c th√¥ng tin c·∫•u h√¨nh
        self.miner_id_readable = miner_id or on_chain_uid_hex
        self.on_chain_uid_hex = on_chain_uid_hex # ƒê√£ ƒë∆∞·ª£c g√°n b·ªüi super() n·∫øu d√πng miner_uid
        self.model_id = model_id

        # Ki·ªÉm tra ƒë·ªãnh d·∫°ng UID hex (t√πy ch·ªçn nh∆∞ng n√™n c√≥)
        try:
            bytes.fromhex(self.on_chain_uid_hex)
        except (ValueError, TypeError):
             logger.error(f"Invalid on_chain_uid_hex provided to Subnet1Miner: '{self.on_chain_uid_hex}'. It must be a valid hex string.")
             # C√≥ th·ªÉ raise l·ªói ·ªü ƒë√¢y ƒë·ªÉ d·ª´ng kh·ªüi t·∫°o n·∫øu UID sai
             # raise ValueError("Invalid on_chain_uid_hex format.")

        logger.info(f"‚ú® [bold]Subnet1Miner[/] initializing for ID: [cyan]'{self.miner_id_readable}'[/] (UID: [yellow]{self.on_chain_uid_hex[:10]}...[/])")
        logger.info(f"   üëÇ Listening on: [bold blue]{self.host}:{self.port}[/]")
        logger.info(f"   ‚û°Ô∏è Validator Submit URL: [link={self.validator_url}]{self.validator_url}[/link]")
        logger.info(f"   üß† Using Image Gen Model: [magenta]{self.model_id}[/]")

        # T·∫£i model AI (c√≥ th·ªÉ m·∫•t th·ªùi gian)
        self.pipe = self._load_model()

    def _load_model(self):
        """T·∫£i model sinh ·∫£nh (v√≠ d·ª•: Stable Diffusion)."""
        logger.info(f"‚è≥ [bold]Loading image generation model[/] ([magenta]{self.model_id}[/])... This may take a while.")
        start_load_time = time.time()
        try:
            # --- Logic t·∫£i model th·ª±c t·∫ø --- 
            logger.debug("   Attempting to load model pipeline...")
            # pipe = StableDiffusionPipeline.from_pretrained(self.model_id)
            # # T·ªëi ∆∞u h√≥a n·∫øu c√≥ GPU
            # if torch.cuda.is_available():
            #     logger.info("   üöÄ CUDA detected. Moving model to GPU.")
            #     pipe = pipe.to("cuda")
            # elif torch.backends.mps.is_available(): # Cho Apple Silicon
            #     logger.info("   üçè MPS detected. Moving model to MPS.")
            #     pipe = pipe.to("mps")
            # else:
            #     logger.info("   üêå No GPU acceleration detected (CUDA/MPS). Running on CPU.")
            
            # >>> Thay b·∫±ng logic t·∫£i model c·ªßa b·∫°n <<<
            # Gi·∫£ l·∫≠p vi·ªác t·∫£i model
            time.sleep(2) 
            pipe = "FAKE_MODEL_PIPELINE" # Placeholder
            # --------------------------------
            load_duration = time.time() - start_load_time
            logger.info(f"‚úÖüß† [bold]Image generation model[/] ([magenta]{self.model_id}[/]) [bold green]loaded successfully[/] in {load_duration:.2f}s.")
            return pipe
        except Exception as e:
            load_duration = time.time() - start_load_time
            logger.exception(f"üí•‚ùå [bold red]Failed[/] to load image generation model '{self.model_id}' after {load_duration:.2f}s: {e}")
            # C√≥ th·ªÉ raise l·ªói ho·∫∑c tho√°t n·∫øu kh√¥ng load ƒë∆∞·ª£c model
            raise RuntimeError(f"Could not load model: {self.model_id}") from e

    def process_task(self, task: TaskModel) -> dict:
        """
        Th·ª±c hi·ªán task v√† tr·∫£ v·ªÅ dictionary ch·ª©a chi ti·∫øt k·∫øt qu·∫£.
        Dict n√†y s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t v√†o tr∆∞·ªùng 'result_data' c·ªßa ResultModel.
        """
        # S·ª≠ d·ª•ng ID d·ªÖ ƒë·ªçc cho logging
        logger.info(f"‚õèÔ∏è [bold]Processing task[/] [yellow]{task.task_id}[/yellow] for miner '{self.miner_id_readable}'")
        start_time = time.time()

        # L·∫•y prompt t·ª´ task.task_data (theo ƒë·ªãnh nghƒ©a TaskModel m·ªõi)
        prompt = task.description

        if not prompt:
            logger.warning(f"Task {task.task_id} received without a valid 'description' in task_data.")
            duration = time.time() - start_time
            return {
                "error": "No prompt provided in task_data.description",
                "processing_time_ms": int(duration * 1000),
            }

        logger.debug(f"Task {task.task_id} - Prompt: '{prompt}'")

        # --- Th·ª±c hi·ªán sinh ·∫£nh --- 
        generated_image = None
        error_message = None
        image_base64_string = None
        generation_start_time = time.time()
        logger.info(f"   ‚è≥ [italic]Starting image generation...[/] (Task: {task.task_id}) ")
        try:
            generated_image = generate_image_from_prompt(prompt=prompt)
            generation_duration = time.time() - generation_start_time
            if generated_image:
                 logger.info(f"   ‚úÖüñºÔ∏è [italic]Image generated successfully[/] in {generation_duration:.2f}s. (Task: {task.task_id}) ")
            else:
                 logger.warning(f"   ‚ö†Ô∏è [italic]Image generation returned None[/] after {generation_duration:.2f}s. (Task: {task.task_id}) ")
        except Exception as e:
            generation_duration = time.time() - generation_start_time
            logger.exception(f"   üí• [italic red]Exception during image generation[/] after {generation_duration:.2f}s: {e} (Task: {task.task_id}) ")
            error_message = f"Generation Error: {type(e).__name__}"
            traceback.print_exc()

        total_duration = time.time() - start_time

        # --- X·ª≠ l√Ω k·∫øt qu·∫£ sinh ·∫£nh --- 
        if generated_image:
            #logger.info(f"Task {task.task_id} - Image generated successfully in {duration:.2f}s.")
            image_base64_string = image_to_base64(generated_image, format="PNG")
            if not image_base64_string:
                logger.error(f"Task {task.task_id} - Failed to convert generated image to base64.")
                error_message = "Error: Failed to encode image result."
        elif not error_message:
            logger.warning(f"Task {task.task_id} - Image generation returned None without specific error.")
            error_message = "Error: Image generation failed silently."
        
        # --- T·∫°o dictionary ch·ª©a chi ti·∫øt k·∫øt qu·∫£ --- 
        result_details = {
            "output_description": image_base64_string if image_base64_string else (error_message or "Error: Unknown processing error"),
            "processing_time_ms": int(total_duration * 1000),
            "generation_time_ms": int(generation_duration * 1000), # Add generation time
            "model_id_used": self.model_id,
            "error_details": error_message
        }
        logger.debug(f"Task {task.task_id} - Prepared result details dict: {str(result_details)[:150]}...")
        logger.info(f"‚úÖ [bold]Finished processing task[/] [yellow]{task.task_id}[/yellow] in {total_duration:.2f}s.")
        return result_details

    def handle_task(self, task: TaskModel):
        """
        (Override) X·ª≠ l√Ω task nh·∫≠n ƒë∆∞·ª£c t·ª´ validator.
        H√†m n√†y ƒë∆∞·ª£c g·ªçi (th∆∞·ªùng trong thread ri√™ng) khi c√≥ task m·ªõi ƒë·∫øn endpoint /receive-task.
        N√≥ s·∫Ω g·ªçi process_task ƒë·ªÉ th·ª±c hi·ªán c√¥ng vi·ªác, sau ƒë√≥ g·ª≠i k·∫øt qu·∫£ v·ªÅ validator g·ªëc.
        """
        # 1. Th·ª±c hi·ªán task ƒë·ªÉ l·∫•y dict k·∫øt qu·∫£ chi ti·∫øt
        # process_task gi·ªù tr·∫£ v·ªÅ dict ch·ª©a chi ti·∫øt k·∫øt qu·∫£ (·∫£nh base64/l·ªói)
        result_details = self.process_task(task)

        # 2. T·∫°o ƒë·ªëi t∆∞·ª£ng ResultModel theo ƒë·ªãnh nghƒ©a m·ªõi
        # Decode hex UID back to string for validator compatibility
        try:
            miner_uid_string = bytes.fromhex(self.on_chain_uid_hex).decode('utf-8')
        except (ValueError, UnicodeDecodeError):
            # Fallback to hex if decode fails
            miner_uid_string = self.on_chain_uid_hex
            
        result_to_send = ResultModel(
            task_id=task.task_id,
            miner_uid=miner_uid_string, # Use decoded string UID
            result_data=result_details, # ƒê·∫∑t dict k·∫øt qu·∫£ chi ti·∫øt v√†o ƒë√¢y
        )

        # 3. X√°c ƒë·ªãnh URL validator g·ªëc ƒë·ªÉ g·ª≠i k·∫øt qu·∫£ v·ªÅ
        target_validator_endpoint = getattr(task, 'validator_endpoint', None)
        submit_url = None

        if target_validator_endpoint and isinstance(target_validator_endpoint, str) and target_validator_endpoint.startswith(("http://", "https://")):
            submit_url = target_validator_endpoint.rstrip('/') + "/v1/miner/submit_result"
        elif self.validator_url:
             submit_url = self.validator_url.rstrip('/') + "/v1/miner/submit_result"
             logger.warning(f"Miner '{self.miner_id_readable}' - No valid validator_endpoint in task {task.task_id}. Using default fallback: {submit_url}")
        else:
             logger.error(f"Miner '{self.miner_id_readable}' - Cannot send result for task {task.task_id}. No validator_endpoint in task and no fallback URL configured.")
             return

        # 4. G·ª≠i ƒë·ªëi t∆∞·ª£ng ResultModel ƒë√£ ƒë∆∞·ª£c serialize
        if submit_url:
            logger.info(f"üì§ Sending result for task '{task.task_id}' (MinerUID: {result_to_send.miner_uid}) to validator: [link={submit_url}]{submit_url}[/link] ...")
            logger.debug(f"   Payload: {str(result_to_send.dict())[:150]}...") # Log payload g·ª≠i ƒëi
            try:
                # D√πng requests (ƒë·ªìng b·ªô)
                response = requests.post(submit_url, json=result_to_send.dict(), timeout=30)

                if 200 <= response.status_code < 300:
                    logger.info(f"‚úÖ Result for task '{task.task_id}' sent successfully (Status: {response.status_code}).")
                else:
                    logger.error(
                        f"‚ùå Failed to send result for task '{task.task_id}'. Validator responded with status {response.status_code}. Response: {response.text[:200]}..."
                    )
            except requests.exceptions.RequestException as req_err:
                 logger.error(f"‚ùå Network error sending result for task '{task.task_id}' to {submit_url}: {req_err}")
            except Exception as send_err:
                 logger.exception(f"üí• Unexpected error sending result for task '{task.task_id}': {send_err}")

    def run(self):
        """Kh·ªüi ch·∫°y Uvicorn server ƒë·ªÉ ch·∫°y API."""
        logger.info(f"‚ñ∂Ô∏è Starting Uvicorn server for Miner '{self.miner_id_readable}' on {self.host}:{self.port}...")
        try:
            uvicorn.run(
                self.app,
                host=self.host,
                port=self.port,
            )
        except Exception as e:
             logger.exception(f"üí• Failed to run Uvicorn server: {e}")

    def _encode_image(self, image: Image.Image) -> str:
        """M√£ h√≥a ƒë·ªëi t∆∞·ª£ng ·∫£nh PIL th√†nh chu·ªói base64."""
        # ... rest of the file